= Creating New Applications
{product-author}
{product-version}
:data-uri:
:icons:
:toc: macro
:toc-title:

toc::[]

== Overview

Create a new OpenShift application by using the
link:../architecture/infrastructure_components/web_console.html[web console] or
by running the `oc new-app` command from the CLI. OpenShift creates a new
application by specifying
link:#specifying-source-code[source code],
link:#specifying-an-image[images], or
link:#specifying-a-template[templates]. The OpenShift
new-app CLI command looks for images on the local Docker installation (if available), in a
link:../architecture/infrastructure_components/image_registry.html[Docker
registry], or an OpenShift image stream.

If you specify source code, new-app will attempt to construct a 
link:builds.html#defining-a-buildconfig[build configuration] 
that will build your source into a new application
link:../architecture/core_concepts/builds_and_image_streams.html#image-streams[image].
It will also construct a 
link:../architecture/core_concepts/deployments.html#deployments-and-deployment-configurations[deployment configuration] that 
will deploy that new image, and a 
link:../architecture/core_concepts/pods_and_services.html#services[service] to provide load balanced
access to the deployment that is running your image.

[NOTE]
====
If you specify source code, you may need to
link:builds.html#starting-a-build[run a build] with `oc start-build` after the
application is created.
====

== Using the CLI

=== Specifying source code

New-app allows you to create applications using source code from a local or a remote git repository.
If only a source repository is specified, new-app will try to automatically
link:#build-strategy-detection[determine the type of]
link:../architecture/core_concepts/builds_and_image_streams.html#builds[build strategy]
to use (`Docker` or `Source`), and in the case of Source type builds,
link:#language-detection[an appropriate language builder image].

You can tell new-app to use a subdirectory of your source code repository by specifying a `--context` flag. Also, when specifying
a remote URL, you can specify a git reference to use by appending `#[reference]` to the end of the URL.


[NOTE]
====
If using a local git repository, the repository must have an `origin` remote that points to a URL accessible by the OpenShift cluster.
====

.Creating an application using the git repository at the current directory
====
----
$ oc new-app .
----
====

.Creating an application using a remote git repository and a context subdirectory
====
----
$ oc new-app https://github.com/openshift/sti-ruby.git --context=2.0/test/puma-test-app
----
====

.Creating an application using a remote git repository with a specific branch reference
====
----
$ oc new-app https://github.com/openshift/ruby-hello-world.git#beta4
----
====


==== Build strategy detection

If new-app finds a `Dockerfile` in the repository, it will generate a 
link:../architecture/core_concepts/builds_and_image_streams.html#docker-build[Docker build strategy], otherwise it will generate a
link:../architecture/core_concepts/builds_and_image_streams.html#source-build[Source strategy]. 
To use a specific strategy set the `--strategy` flag to either `source` or `docker`.

.Force new-app to use the Docker strategy for a local source repository
====
----
$ oc new-app /home/user/code/myapp --strategy=docker
----
====

==== Language detection
If creating a Source build, new-app will attempt to determine which language builder to use based on the presence of certain files
in the root of the repository:

.Languages detected by new-app
[cols="4,8",options="header"]
|===

|Language |Files

a|`ruby`
a|Rakefile, Gemfile, config.ru

a|`jee`
a|pom.xml

a|`nodejs`
a|app.json, package.json

a|`php`
a|index.php, composer.json

a|`python`
a|requirements.txt, config.py

a|`perl`
a|index.pl, cpanfile
|===

Once a language is detected, new-app will search the OpenShift server for image stream tags that have a `supports` annotation
that matches the detected language or an image stream that matches the name of the detected language. If a match is not found, 
the DockerHub registry is searched for an image that matches the detected language based on name.

To override the image that new-app uses as the builder for a particular source repository, the image (either as image stream or Docker
specification) can be specified along with the repository using a `~` as a separator.

.Use image stream myproject/my-ruby to build the source at a remote github repository
====
----
$ oc new-app myproject/my-ruby~https://github.com/openshift/ruby-hello-world.git
----
====

.Use Docker image openshift/ruby-20-centos7:latest to build source in a local repository
====
----
$ oc new-app openshift/ruby-20-centos7:latest~/home/user/code/my-ruby-app
----
====

=== Specifying an image

New-app will generate the necessary artifacts to deploy an existing image as an application. Images can come from image streams in
the OpenShift server, images in a specific registry or DockerHub, or images in the local Docker server. New-app will attempt to determine
the type of image specified in the arguments passed to it. However, you can explicitly tell new-app whether the image is a docker image (using the 
`--docker-image` argument) or an image stream (using the `-i|--image` argument).


[NOTE]
====
If you specify an image from your local Docker repository, you will need to ensure that the same image is available
to the OpenShift cluster nodes.
====



.Creating an application from the https://registry.hub.docker.com/_/mysql/[DockerHub MySQL Image]:
====
----
$ oc new-app mysql
----
====

To create an application using an image in a private registry, specify the full Docker image specification:
.Creating an application from a local registry
----
$ oc new-app myregistry:5000/example/myimage
----

[NOTE]
====
If the registry that the image comes from is not secured with SSL, make sure that the Docker daemon on the OpenShift nodes
is run with the `--insecure-registry` flag pointing to that registry. You also need to tell new-app that the image comes from 
an insecure registry with the `--insecure-registry=true` flag.
====

To create an application from an existing 
link:../architecture/core_concepts/builds_and_image_streams.html#image-streams[image stream], specify the namespace (optional), name, and tag (optional) for the 
image stream:

.Create an application from an existing image stream, with a specific tag
====
----
$ oc new-app my-stream:v1
----
====

=== Specifying a template

New-app can instantiate a link:templates.html[template] from a previouly stored template 
or from a template file.
To instantiate a  a previously-stored template, specify the name of the template 
as an argument. For example, store a
https://github.com/openshift/origin/tree/master/examples/sample-app[sample
application template] and use it to create an application:

.Creating an application from a previously stored template
====
----
$ oc create -f examples/sample-app/application-template-stibuild.json
$ oc new-app ruby-helloworld-sample
----
====

To use a template in the file system directly, without first storing it in OpenShift, use
the `-f|--file` argument or simply specify the file name as the argument to new-app:

.Creating an application from a template in a file
====
----
$ oc new-app -f examples/sample-app/application-template-stibuild.json
----
====

==== Template parameters

When creating an application based on a link:templates.html[template],
use the `-p|--param` argument to set parameter values defined by the template:

.Specifying template parameters with a template
----
$ oc new-app ruby-helloworld-sample -p ADMIN_USERNAME=<user>,ADMIN_PASSWORD=<pass>
----

=== Specifying environment variables

When generating applications from 
link:#specifying-source-code[source] or an
link:#specifying-an-image[image], you can use the `-e|--env` argument to specify environment
to be passed to the application container at run time.

.Setting environment variables when creating an app for a database image
----
$ oc new-app openshift/postgresql-92-centos7 -e POSTGRESQL_USER=user -e POSTGRESQL_DATABASE=db -e POSTGRESQL_PASSWORD=pass
----


=== Specifying labels

When generating applications from
link:#specifying-source-code[source],
link:#specifying-an-image[images], or 
link:#specifying-a-templates[templates], you can use the `l|--label` argument to add labels to objects created by new-app.
This is recommended, as labels make it easy to collectively select, manipulate, and delete objects
associated with the application.

.Using the label argument to label objects created by new-app
====
----
$ oc new-app https://github.com/openshift/ruby-hello-world -l name=hello-world
----
====

=== New-app Output

New-app will generate OpenShift resources that will build, deploy and run the application being created. Normally, these 
resources are created in the current project using names derived from the input source repositories or the input images. However,
new-app allows you to modify this behavior.

==== Output without creation
To see a dry-run of what new-app will create, you can use the `-o|--output` flag with a value of either `yaml` or `json`. You can 
then use the output to preview the resources that will be created or redirect it to a file 
that you can edit and then use with `oc create` to create the OpenShift resources.


.Output new-app artifacts to a file, edit them and then create them using `oc create`
====
----
$ oc new-app https://github.com/openshift/ruby-hello-world -o json > myapp.json
$ vi myapp.json
$ oc create -f myapp.json
----
====

==== Object names
Objects created by new-app are normally named after the source repository or the image used to generate them. You can set the 
name of the objects produced by adding a `--name` flag to the command.

.Create new-app artifacts with a different name
====
----
$ oc new-app https://github.com/openshift/ruby-hello-world --name=myapp
----
====

==== Object project or namespace
Normally new-app creates objects in the current project. However, you can tell it to create objects in a different project that
you have access to using the `-n|--namespace` argument.


.Create new-app artifacts in a different project
====
----
$ oc new-app https://github.com/openshift/ruby-hello-world -n myproject
----
====

==== Artifacts created by new-app

The set of artifacts created by new-app depends on the artifacts passed as input (source repositories, images, or templates)

.New-app output resources
[cols="2,8",options="header"]
|===

|Artifact |Description

a|BuildConfig
a|A BuildConfig is created for each source repository specified in the command line. The BuildConfig
  specifies the strategy to use, the source location and the build output location.

a|ImageStreams
a|For BuildConfigs, two ImageStreams are usually created, one to represent the input image (builder image in case of
  Source builds or FROM image in case of Docker builds), and another one to represent the output image.
  If a Docker image was specified as input to new-app then an image stream will be created for that image as well.

a|DeploymentConfig
a|A deployment config will be created either to deploy the output of a build, or a specified image.

a|Service
a|New-app will attempt to detect exposed ports in input images. It will use the lowest numeric exposed port to 
  generate a service that exposes that port. In order to expose a different port, after new-app has completed, simply use
  the `oc expose` command to generate additional services.

a|Other
 |Other resources can be generated when instantiating templates.
  
|===

=== Advanced: Multiple components and grouping

New-app allows creating multiple applications from 
link:#specifying-source-code[source], 
link:#specifying-an-image[images], or 
link:#specifying-templates[templates] at once. 
To do this, simply specify multiple parameters to the new-app call. Labels 
specified in the commannd line will apply to all objects created by the one call. 
Environment variables will apply to all components created from source or images.

.Creating an application from a source repository and a DockerHub image
====
----
$ oc new-app https://github.com/openshift/ruby-hello-world mysql
----
====

[NOTE]
====
If a source code repository and a builder image are specified as separate arguments, new-app will use the builder image as the builder
for the source code repository. If this is not the intent, simply specify a specific builder image for the source using the `~` separator.
====

==== Grouping images and source in a single pod
New-app allows deploying multiple images together in a single pod. In order to specify which images to group together, use the `+` separator. The 
`--group` command line argument can also be used to specify which images should be grouped together. To group the image built from a source repository
with other images, specify its builder image in the group.

.Deploying two images in a single pod
====
----
$ oc new-app nginx+mysql
----
====

.Deploying an image built from source and external image together
====
----
$ oc new-app ruby~https://github.com/openshift/ruby-hello-world mysql --group=ruby+mysql
----
====


== Using the Web Console

You can also create applications using the
link:../architecture/infrastructure_components/web_console.html[web console]:

1. While in the desired project, click *Create+*:
+
====

image::console_create.png["Web Console Create"]
====

2. Enter the repository URL for the application to build:
+
====

image::console_enter_source_uri.png["Enter Source Repository"]
====

3. Select either a builder image from the list of images in your project, or
from the global library:
+
====

image::console_select_image.png["Select Builder Image"]
====

4. Modify the settings in the new application screen to configure the resources
to support your application:
+
====

image::create_from_image.png["Create from source"]
====
<1> The builder image name and description.
<2> The application name used for the generated OpenShift resources.
<3> Routing configuration section for making this application publicly accessible.
<4> Deployment configuration section for customizing deployment triggers and image environment variables.
<5> Build configuration section for customizing build triggers.
<6> Replica scaling section for configuring the number of running instances of the application.
<7> The labels to assign to all items generated for the application. You can add and edit labels for all resources here.
