// Module included in the following assemblies:
//
// * operators/operator-reference.adoc
// * post_installation_configuration/machine-configuration-tasks.adoc

[id="machine-config-overview{context}"]
= MachineConfig overview

The Machine Config Operator (MCO) lets you apply changes to
the operating systems running on {product-title} nodes.
Understanding what MCO does and how it interacts with other components
is critical to making advanced, system-level changes to an
{product-title} cluster. Here are some things you should know about MCO,
MachineConfigs, and how they are used:

* The most common way to use MCO is to create a MachineConfig that
makes a specific change to a file or service on the operating system
for each system representing a pool of {product-title} nodes.

* MCO applies operating system changes to pools of machines. All {product-title} clusters
start with bootstrap, worker, and master node pools. By adding more
role labels, you can configure special pools of nodes. So, for example,
you could set up special worker nodes that include particular hardware
features needed by an application. However, examples in this section focus
on changes to the default pool types.

* Some per node configuration must be in place before {product-title} is
is installed to disk. In most cases, this can be accomplished by creating
a MachineConfig that is injected directly into the {product-title} installer
process, instead of running as a post-installation MachineConfig.
In other cases, you might need to do bare metal installation where you
pass kernel arguments at {product-title} installer start-up, to do such
things as set per-node individual IP addresses or advanced disk partitioning.

* MCO manages items that are set in MachineConfigs. Manual changes you do to
your systems will not be overwritten by MCO, unless MCO is explicitly told to
manage a conflicting file. In other words, MCO only makes specific updates
you request, it does not claim control over the whole node.

* Direct changes to nodes are strongly discouraged. If you need to decommission
a node and start a new one, those direct changes would be lost.

* MCO can only be set to write to files in `/etc` and `/var` directories, although
there are symbolic links to some directories that can be writeable by being
symbolically linked to one of those areas. The `/opt` directory is an example.

* Ignition is the configuration format used in MachineConfigs. See the
link:https://github.com/coreos/ignition/blob/master/docs/configuration-v3_1.md[Ignition Configuration Specification v3.1.0]
for details.

* Although Ignition config settings can be delivered directly at {product-title}
installation time, and are formatted in the same way that MCO delivers Ignition
configs, MCO has no way of seeing what those original Ignition configs are. So, whenever
possible, you should wrap Ignition config settings into a MachineConfig before
deploying them.

* When a MachineConfig managed by MCO changes outside of MCO, the Machine
Config Daemon (MCD) sets the machine as degraded. It won't overwrite the
offending file, however, and should continue to operate in a degraded state.

* A key reason for using a MachineConfig is that it will be applied when
you spin up new nodes in your {product-title} cluster. The machine-api-operator
provisions a new machine and MCO configures it.

=== What can you change with MachineConfigs?
The kinds of components that MCO can change include:

* **config**: Create Ignition config objects (see the
link:https://github.com/coreos/ignition/blob/master/docs/configuration-v3_1.md[Ignition configuration specification])
to do things like modify files, systemd services, and other features on {product-title} machines, including:
- **Configuration files**: Create or overwrite files in the `/var` or `/etc` directory.
- **systemd units**: Create and set the status of a systemd service or add to an existing systemd service by dropping in additional settings.
- **users and groups**: Change system user and group settings.
- **security**: Set TLS resources for making  https connections.
* **kernelArguments**: Add arguments to the kernel command line when {product-title} nodes boot.
* **kernelType**: Optionally identify a non-standard kernel to use instead of the standard kernel. Use `realtime`
to use the RT kernel.
* **fips**: Enable link:https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html-single/security_hardening/index#using-the-system-wide-cryptographic-policies_security-hardening[FIPS]
mode. FIPS should be set at
installation-time setting and not a post-installation procedure.
* **extensions**: Extend {op-system} features by adding selected pre-packaged software.
For this feature (new in {product-title} 4.6), available extensions include
link:https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html-single/security_hardening/index#protecting-systems-against-intrusive-usb-devices_security-hardening[usbguard] and kernel modules
* **Custom resources (for ContainerRuntime and Kubelet)**: Outside of
MachineConfigs, MCO manages two special custom resources for modifying
CRI-O container runtime settings (ContainerRuntime CR) and the
Kubelet service (Kubelet CR).

The MCO is not the only facility that can change operating
system components on {product-title} nodes. Other Operators
can make operating system-level features as well. One example
is the link:https://docs.openshift.com/container-platform/4.5/operators/operator-reference.html#about-node-tuning-operator_red-hat-operators[Node tuning operator], which allows you to do node-level tuning through Tuned daemon profiles.

Tasks for the MCO configuration that can be done post-installation
are included in procedures that follow here. See descriptions of
{op-system} bare metal installation for system configuration
tasks that must be done during or before {product-title} installation.

== Project

link:https://github.com/openshift/machine-config-operator[openshift-machine-config-operator]
